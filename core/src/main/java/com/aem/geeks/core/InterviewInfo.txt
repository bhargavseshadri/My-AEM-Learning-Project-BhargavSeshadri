ONLY INTERVIEW RELATED MATERIAL

=============================================================================================
Basic Important Points

-> Implimentation used for creating AEM is - APACHE JACKRABBIT OAK
-> Implimentation used by JCR is - APACHE JACKRABBIT OAK, Apache oak
-> To connect AEM to crxde we use Apache sling
-> We can also use LAZY BONES instead of maven
-> For restricting the image types we use mimeTypes = "[]"
-> to make it required through dialog box -> required = "{Boolean}true"
-> For textfield or text areas : maxLength = "{Long}10"
-> For setting range : min = "{double}1000" , max = "{double}1000"
-> cq:design_dialog only used for static templates

=============================================================================================
DEFINITIONS
1) Resource : Resource can be anything, it can be COMPONENT, NODE, PAGE.
2) Immediate = true -> Whenever we want to activate the service immediately after the bundle gets started in that place we use this.
3) req.setAttribute() AND req.getAttribute() :  storing temporary data in the HttpServletRequest object using setAttribute() and later read it back using getAttribute().
4) Headless CMS : and application or the CMS seperate there content from any other layer like presentation layer, and that seperated content will we served by the third party system, then it is called headless.

=============================================================================================
AEM & OSGI ARCHITECTURE

OSGI ARCHITECTURE:
1. Service Layer: we can write reusable code and establishing the connection between bundles
2. Life cycle layer: it deals with all the life cycle processess of the bundle(install, start, update, stop, uninstalling the bundles)
3. Modules layer: it deals with the exporting and importing of the packages, these packages contains classes, interfaces, components.
4. Execution environment: It is the runtime environment of the java and responsible for loading the relevant classes at the time of execution

AEM ARCHITECTURE:
--> Application layer : Here we have various ca[pabilities like sites, forms, etc
--> WEB APPLICATION FRAMEWORK(apache sling) : rest based web application framework, helps in cosuming and exposing the content in jcr and interaction with osgi java container
--> JCR Repositiry(apache jack rabbit oak)(storage layer): what ever the content that author added will be stored here
--> OSGI JAVA CONTAINER(apache felix): used for moduler development, and provides various functionalities in form of modules, components etc

=============================================================================================
==> Lifecycle in OSGi
- A typical OSGi component has 3 important lifecycle annotations:
1) @Activate - When the component is first started (activated), it Initialize resources, read configuration
2) @Modified - When configuration is changed dynamically, it Re-read and apply new config
3) @Deactivate - When the component is stopped


=============================================================================================
==> SERVLETS

-> When a servlet runs, Sling (and the underlying web server Jetty) automatically gives it two key objects:
   SlingHttpServletRequest → the HTTP request (what the browser sent)
   SlingHttpServletResponse → the HTTP response (what you send back)

a) ResourceType Servlets
-> Methods, extensions and Selectors will only work for resourceType servlets. (ResourceType is manditory in these and others are optional)
-> so we give a Resource in the servlet, and whenever that resource is accessed, our servlet will be "CALLED".
-> ResourceType Servlets : @SlingServletResourceType()
-> Here we can use extensions, Selectors, and methods
- these servlets can be accessed controlled using a jcr repo ACL
- if we do not provide any method then the default method is GET

b) PathType Servlets
-> Path @SlingServletPaths(value=__)
-> ACL access is not present
-> fixed url endpoint

-> Benifits
- Creating utility endpoints (like APIs)
- Handling AJAX calls from frontend
- Exposing data externally

Q) Why in aem servlet code they use protedted void for get and post methods, what's the reason?
Ans. 1) Servlets extend a base class (SlingAllMethodsServlet or HttpServlet), In those parent classes, the doGet() and doPost() methods are already
declared as protected. So when you override them, you must keep the same access modifier (protected), otherwise Java will throw an error (you can’t reduce visibility of an overridden method).
2) they are marked as protected to limit access (i.e., only subclasses or the framework should call them).

=============================================================================================
SCHEDULERS
-> Runnable : imp method that starts the execution is -- run()
-> Job : imp method that starts the execution is -- execute(JobContext jobContext)

-> ScheduleOptions scheduleOptions = scheduler.EXPR(config.cronExpression());

=============================================================================================
OSGI CONFIGURATIONS:
Definition: Initial set of inputs given to a bundle. like giving the input to our java file or component in that case we use osgi configurations
-> Type of inputs: Text Field, Multifield, Checkbox, Dropdown

- Factory Configuration: When we want to create more than one instance on the configuration, in that case we create factory configuration.
Normal congfig to Factory Config : @Designate(ocd = BhargavFactoryOSGiConfig.class, factory=true)

==> cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC
- sometimes, we may have: Multiple implementations of the same interface (or) Services that appear or disappear dynamically (e.g., bundles starting/stopping).
(Or) we may want to handle such changes gracefully. then in that case ReferenceCardinality and ReferencePolicy come into play.
- ReferenceCardinality → How many services can be injected
                    a) MANDATORY : Must have exactly one service available. If not present, this component won’t activate.
                    b) OPTIONAL : May or may not have one service
                    c) MULTIPLE  : Can have many implementations injected (a list).
                    d) AT_LEAST_ONE : Must have at least one available.

- ReferencePolicy → When to update the reference
                  a) STATIC :  It won't considers the unbind method with bind method. Injects dependency only once during activation.
                  b) DYNAMIC : It will automatically considers the unbind method with bind method. Automatically updates the reference at runtime when services appear/disappear.

=============================================================================================
RUN MODES: in AEM are like environment identifiers that tell AEM how it should behave in different environments — for example: author, publish, development, staging, production, etc.
In short:
   Run modes allow you to configure AEM differently for different environments without changing the code.
   Two types:
   1. installation run modes
   2. custom run modes

=============================================================================================
CORE COMPONENTS & PROXY COMPONENTS

-> CORE COMPONENTS: Core Components are a set of ready-made, production-ready components provided by Adobe (like Text, Image, Carousel, Button, Title, etc.) as part of AEM.'
path : /apps/core/wcm/components/...

-> PROXY COMPONENTS: A proxy component is a lightweight wrapper around a core component. It doesn’t add new logic — it just points to a core component using
 sling:resourceSuperType and gives it a project-specific name and path. and it allows future customization without touching core code.

=============================================================================================
CRXDE FOLDER STRUCTURE

-> apps: proxy comps, core comps, and static templates
-> conf: configuration files related to the project are stored here, and also editable templates
-> content: all the webpages, (static pages, dynamic pages, js, css) and digital assets are present here
-> ETC: contains all the resources related to the tools are stored here
-> Users: contains all the info of users and groups
-> libs: OOTB things present here, we can use this but we cant modify

=============================================================================================
MODELS & SERVICES

PROBLEM: for one SERVICE interface class ,there is two implimentation classes, so in this scenario, which service have to executed?

-> In this case we have two options
1) @ServiceRanking(1000) : class level annotation so according to this, which service have the higher service rank; then that service gets executed.
2) @OSGiService(filter="(component.name=__________)") : the other option is using "filter" in sling model, so based on which
                                                        service name we have given to the filter that service gets executed for that sling model.
                                                        Note: for this we have to give a name to the service in @Component.

=============================================================================================
