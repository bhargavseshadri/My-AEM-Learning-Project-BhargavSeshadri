ONLY INTERVIEW RELATED MATERIAL

=============================================================================================
Basic Important Points

-> Implimentation used for creating AEM is - APACHE JACKRABBIT OAK
-> Implimentation used by JCR is - APACHE JACKRABBIT OAK, Apache oak
-> To connect AEM to crxde we use Apache sling
-> We can also use LAZY BONES instead of maven
-> For restricting the image types we use mimeTypes = "[]"
-> to make it required through dialog box -> required = "{Boolean}true"
-> For textfield or text areas : maxLength = "{Long}10"
-> For setting range : min = "{double}1000" , max = "{double}1000"
-> cq:design_dialog only used for static templates
-> immediate=true Whenever we want to activate the service immediately after the bundle gets started in that place we use this.
-> Apache Sling : Apache Sling is a web framework used by AEM that maps HTTP requests to content resources stored in the JCR (Java Content Repository) and
                  renders responses dynamically.
-> OSGI : OSGi (Open Services Gateway initiative) is a Java-based modular framework that allows AEM to run applications as independent, reusable, and dynamically
          updatable components called bundles.

=============================================================================================
DEFINITIONS
1) Resource : Resource can be anything, it can be COMPONENT, NODE, PAGE.
2) Immediate = true -> Whenever we want to activate the service immediately after the bundle gets started in that place we use this.
3) req.setAttribute() AND req.getAttribute() :  storing temporary data in the HttpServletRequest object using setAttribute() and later read it back using getAttribute().
4) Headless CMS : and application or the CMS seperate there content from any other layer like presentation layer, and that seperated content will we served by the third party system, then it is called headless.
5) ValueMap : In AEM, valueMap is a special map like object that store and retrives properties of a JCR node in a convinient way, its a wrapper around our node and hepls us in
                accessing the properties of that node.
6) Services: AEM Services are OSGi components (Java classes) that contain business logic or reusable functionality, and can be shared across different parts of the AEM application.

=============================================================================================
AEM & OSGI ARCHITECTURE

OSGI ARCHITECTURE:
1. Service Layer: we can write reusable code and establishing the connection between bundles
2. Life cycle layer: it deals with all the life cycle processess of the bundle(install, start, update, stop, uninstalling the bundles)
3. Modules layer: it deals with the exporting and importing of the packages, these packages contains classes, interfaces, components.
4. Execution environment: It is the runtime environment of the java and responsible for loading the relevant classes at the time of execution

AEM ARCHITECTURE:
-->4. Application layer : Here we have various ca[pabilities like sites, forms, etc
-->3. WEB APPLICATION FRAMEWORK(apache sling) : rest based web application framework, helps in cosuming and exposing the content in jcr and interaction with osgi java container
-->2. JCR Repositiry(apache jack rabbit oak)(storage layer): what ever the content that author added will be stored here
-->1. OSGI JAVA CONTAINER(apache felix): used for moduler development, and provides various functionalities in form of modules, components etc

=============================================================================================
==> Lifecycle in OSGi
- A typical OSGi component has 3 important lifecycle annotations:
1) @Activate - When the component is first started (activated), it Initialize resources, read configuration
2) @Modified - When configuration is changed dynamically, it Re-read and apply new config
3) @Deactivate - When the component is stopped


=============================================================================================
==> SERVLETS
- A Servlet is a Java class that  handles HTTP requests (like GET, POST) and generates HTTP responses (like HTML, JSON, XML).

-> When a servlet runs, Sling (and the underlying web server Jetty) automatically gives it two key objects:
   SlingHttpServletRequest → the HTTP request (what the browser sent)
   SlingHttpServletResponse → the HTTP response (what you send back)

a) ResourceType Servlets
-> Methods, extensions and Selectors will only work for resourceType servlets. (ResourceType is manditory in these and others are optional)
-> so we give a Resource in the servlet, and whenever that resource is accessed, our servlet will be "CALLED".
-> ResourceType Servlets : @SlingServletResourceType()
-> Here we can use extensions, Selectors, and methods
- these servlets can be accessed controlled using a jcr repo ACL
- if we do not provide any method then the default method is GET
-> Cases when we prefer ResourceType
a) Dynamic component behavior: When the servlet needs to render or process requests specific to a component.
b) Component-based JSON export: For example, exporting data only for a news-page component.
c) Great for component-specific functionality.

b) PathType Servlets
-> Path @SlingServletPaths(value=__)
-> ACL access is not present
-> fixed url endpoint

-> Benifits of pathType
- when we want our servlet to be Independent of page/component structure then we use this pathType.
- Creating utility endpoints (like APIs)
- Handling AJAX calls from frontend
- Exposing data externally

Q) Why in aem servlet code they use protedted void for get and post methods, what's the reason?
Ans. 1) Servlets extend a base class (SlingAllMethodsServlet or HttpServlet), In those parent classes, the doGet() and doPost() methods are already
declared as protected. So when you override them, you must keep the same access modifier (protected), otherwise Java will throw an error (you can’t reduce visibility of an overridden method).
2) they are marked as protected to limit access (i.e., only subclasses or the framework should call them).

=============================================================================================
SCHEDULERS
-> Runnable : imp method that starts the execution is -- run()
-> Job : imp method that starts the execution is -- execute(JobContext jobContext)

-> ScheduleOptions scheduleOptions = scheduler.EXPR(config.cronExpression());

=============================================================================================
OSGI CONFIGURATIONS:
Definition: Initial set of inputs given to a bundle. like giving the input to our java file or component in that case we use osgi configurations
-> Type of inputs: Text Field, Multifield, Checkbox, Dropdown

- Factory Configuration: When we want to create more than one instance on the configuration, in that case we create factory configuration.
Normal congfig to Factory Config : @Designate(ocd = BhargavFactoryOSGiConfig.class, factory=true)

==> cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC
- sometimes, we may have: Multiple implementations of the same interface (or) Services that appear or disappear dynamically (e.g., bundles starting/stopping).
(Or) we may want to handle such changes gracefully. then in that case ReferenceCardinality and ReferencePolicy come into play.
- ReferenceCardinality → How many services can be injected
                    a) MANDATORY : Must have exactly one service available. If not present, this component won’t activate.
                    b) OPTIONAL : May or may not have one service
                    c) MULTIPLE  : Can have many implementations injected (a list).
                    d) AT_LEAST_ONE : Must have at least one available.

- ReferencePolicy → When to update the reference
                  a) STATIC :  It won't considers the unbind method with bind method. Injects dependency only once during activation.
                  b) DYNAMIC : It will automatically considers the unbind method with bind method. Automatically updates the reference at runtime when services appear/disappear.

=============================================================================================
RUN MODES: in AEM are like environment identifiers that tell AEM how it should behave in different environments — for example: author, publish, development, staging, production, etc.
In short:
   Run modes allow you to configure AEM differently for different environments without changing the code.
   Two types:
   1. installation run modes
   2. custom run modes

=============================================================================================
CORE COMPONENTS & PROXY COMPONENTS

-> CORE COMPONENTS: Core Components are a set of ready-made, production-ready components provided by Adobe (like Text, Image, Carousel, Button, Title, etc.) as part of AEM.'
path : /apps/core/wcm/components/...

-> PROXY COMPONENTS: A proxy component is a lightweight wrapper around a core component. It doesn’t add new logic — it just points to a core component using
 sling:resourceSuperType and gives it a project-specific name and path. and it allows future customization without touching core code.

=============================================================================================
CRXDE FOLDER STRUCTURE

-> apps: proxy comps, core comps, and static templates
-> conf: configuration files related to the project are stored here, and also editable templates
-> content: all the webpages, (static pages, dynamic pages, js, css) and digital assets are present here
-> ETC: contains all the resources related to the tools are stored here
-> Users: contains all the info of users and groups
-> libs: OOTB things present here, we can use this but we cant modify

=============================================================================================
SLING MODELS & SERVICES

PROBLEM: for one SERVICE interface class ,there is two implimentation classes, so in this scenario, which service have to executed?

-> In this case we have two options
1) @ServiceRanking(1000) : class level annotation so according to this, which service have the higher service rank; then that service gets executed.
2) @OSGiService(filter="(component.name=__________)") : the other option is using "filter" in sling model, so based on which
                                                        service name we have given to the filter that service gets executed for that sling model.
                                                        Note: for this we have to give a name to the service in @Component.

=============================================================================================
BASEPAGE COMPONENT
- The Base Page Component in AEM is a common parent component that defines the shared structure and behavior for all pages. Other page components like
  homepage or content page extend it using sling:resourceSuperType, so they automatically inherit its HTML structure and scripts. It helps maintain
  consistency, reuse, and easy maintenance across all pages.
  Example: -> create your own base page component and point it to core page component using sling:resourceSupertype.
           -> And based on our need we can create a Templates and pages and give the sling:ResourceType points to our base page component (in these comps we can use/inherit the files which are
           either present in our page component or base core base page comp)


-------------------------------------------
TEAMPLETS IN AEM
- In AEM, a template defines the structure of a page — i.e., what components can appear, and how the page looks.
- When you create a new page, you select a template — that template decides: layout/structure of the page, Which components authors can use, Default content policies

* STATIC TEMPLATES:
- Static templates are the older way of creating templates in AEM. They are stored under /apps, and their structure is fixed and not editable by authors.
- page structure and allowed components are fixed and can only be changed through code.
- Structure of this template is Defined using a static .content.xml and a page component.
- Authors cannot modify structure (like adding new components or layouts).
- Uses Design mode in classic UI to control allowed components.
- Developers must change code to modify template structure.
- These templates are Fixed (developer controlled)

** CREATING STATIC TEMPPLATE : we have to create a template and that template resourceType should point to our page component or component we want.

* EDITABLE TEMPLATES:
- Editable templates are the modern, flexible templates introduced in AEM 6.2+. They are stored under /conf, and allow authors (not just developers) to
  control structure and policies via the Template Editor UI.
- Controlled via Content Policies in Template Editor.
- no developer needed to change structure
- These templates are Dynamic (author controlled)

-------------------------------------------
CONTENT POLICIES - THINGS WE CAN DO IN IT

- In here we can control what authors can do and how components behave/look, without touching the actual component code.
USES: - Control which components are allowed
      - Define Styles : we can define CSS style classes that authors can apply to components.
      - Define Responsive Behavior : Control layout settings (e.g., grid sizes, breakpoints) for different devices.

Q) What is the link between content policy and component?
→ Each component instance on a page references a policy via cq:policy property.

=============================================================================================
WORKFLOWS in AEM

- workflows allow us to automate a task or a series of tasks. these tasks are most performed on content like pages or assets.
- A workflow needs a workflow model, and the WF model contains a series of steps.
- Workflow Steps are of Four Types:
        1. Container Step : When we want to trigger an another model or another WF, in those case we use this step
        2. Participant step : When we want a human interraction in our WF, like assigning a task to a human, in those case we use this step.
        3. Decision Step : Performing a task based on a condition, mainly when we need a branching in our WF, in those case we use this step.
                                -> This is two types : OR, AND
        4. Process Step : Custom WF processess are used using this process step. we will write our own custom process code and then we link that code with this step.

- Calling of the Model : there are mainly 3 ways
                                  1. Manual Trigger
                                  2. Using Launcher : automating the trigger
                                  3. Using API/Code : we can trigger the WF using any of the backend module like servlet, scheduler, Models etc

=============================================================================================
CLIENTLIBRARIES

* If the clientlib is in our component, in that case we need not to include that clientlib category manually in our comp xml.
* If the Clientlib is not under our component, if it in a shared or global path like /apps/yourproject/clientlibs then you must manually reference
it in your component dialog or template, because AEM won’t auto-link global dialog clientlibs.

Including it in component or editable templates/page components XML: <cq:includeClientLib categories="myproject.dialog"/>
=============================================================================================




































=============================================================================================
ALL ABOUT **JAVA**
- Java is a high-level, object-oriented programming language.
- Java → Statically typed (type is checked at compile time).
=============================================================================================
Quick Important Points
* Array is mutable we can modify it. we can change the value in the particular place but we cant change the size of an array.
* String is immutable.
* Private method can't be overriden.
* FINAL METHOD cannot be overloaded and overridden in child classes.
* Abstract method: method with no body.
* Concrete method: Method with body.
* To convert and array in to a List -> Arrays.asList(arrName);
* To convert a List to an Array -> v1.toArray()
* We can't give primitive datatypes(int, String, Boolean) to generics.
* The collections that implement the Set interface don’t allow duplicates. (HashSet, LinkedHashSet, TreeSet)
* In collection Hashtable, TreeSet won't take null values.
* We cannot directly create an object of an abstract class or an interface in Java. because they have unimplemented (abstract) methods — so
  Java doesn’t know how to create a complete object from it.

=============================================================================================

1) Call by value : In Java, call by value means that when you pass a variable to a method, a copy of the variable’s value is passed — not the actual
variable itself. So, any changes made to the parameter inside the method do not affect the original variable outside the method.

-----------------------------------------------------------
2) Garbage Collection : Garbage Collection in Java is a process by which Java automatically removes unused or unreferenced objects from memory (the heap) to free up space.
- When you create objects in Java using new, they take up memory. If no part of your program is using that object anymore (no references to it), Java will
   automatically detect it and delete it from memory — this process is called Garbage Collection.

- Types of memories in java:
    a)Stack: For Reference variables, method calls and local variables. Stack memory is used for method execution. It stores local variables and method calls.
             The memory is automatically cleared when the method finishes.
    b)Heap : For objects and instance variables. Heap memory is used to store objects created using new. It is shared by all parts of the program.
             Objects in the heap stay there until they are no longer referenced, then garbage collection removes them.

-----------------------------------------------------------
3) STATIC
- static in Java means something that belongs to the class, not to any object, and it "can be accessed" without creating an object using classname.
- The main use of static is to define common things that should be shared across all objects — and to access them without creating an object. and it is
  helpful for memory management.
* To access a non-static method in static method, we have to create an object.
* Static method can only access the static variables.
* To Access normal instance variables we have to create a object of that class and through that obj we access those class instance variables.
* Static methods can only access static methods
* Non-Static can access both static and non-static methods.
* Static does not support "this" and "super"
* And we don't give the access modifier for the variables defined inside the static method.

-----------------------------------------------------------
4) Dynamic Binding (also called Late Binding or Runtime Polymorphism) : it means that the method to be called is decided at runtime, not at compile time.
- here we create a reference for a parent class and assign to the child object.

Eg: Animal a;

    if (userInput.equals("dog")) {
        a = new Dog();
    } else {
        a = new Cat();
    }

    a.sound();  // Which method should run? Java decides at runtime, based on the user given data, if he gives dog then it picks the Dog object


-----------------------------------------------------------
5) ABSTRACT CLASS

- An abstract class in Java is a class that cannot be instantiated on its own and can have abstract methods (methods without a body)
  as well as regular methods (with a body).
- Declared using the keyword abstract.
- Can have both abstract and concrete methods.
- A subclass that extends an abstract class must implement all abstract methods (unless it’s also abstract).
- Used To define a template for subclasses.
- To allow code reuse by including concrete methods in the abstract class.

eg:
abstract class Animal {
    // Abstract method (no body)
    abstract void sound();

    // Regular method
    void sleep() {
        System.out.println("Animal is sleeping");
    }
}

-> Animal obj = new Animal(); //Not allowed

Note: Cannot be instantiated” means that you cannot create an object of that class directly using the new keyword.

-----------------------------------------------------------
6) INTERFACES
- Its like a plan for a classes
- Interfaces are used to define a contract that classes must follow. Any class that implements an interface must provide the implementation
  for its abstract methods.
- Interfaces contains only abstract methods.
- In interfaces all the methods are abstract and all the variables are public, static, final
- Using this we can achieve multiple inheritance (since Java does not support multiple class inheritance).
- we cannot create object for interfaces.

-----------------------------------------------------------
-----------------------------------------------------------
OOPS

1) Abstraction :
- Abstraction is the concept of hiding the internal implementation of a class and showing only the functionality to the user.
- We hide the unnecessary details.

Eg: Interfaces, Abstract classes

------------------------
2) Inheritance : Inheritance in Java is a concept where one class can use the properties and methods of another class.
- Types of inheritance that java supports:
a) Single Inheritance [SUPPORTED]
b) Multilevel Inheritance : b inherits a , and c inherits b [SUPPORTED]
c) Hierarchical Inheritance: Multiple classes inherit from one parent class. [SUPPORTED]
eg: class A { }
    class B extends A { }
    class C extends A { }

d) Multiple Inheritance (by classes) : A class inherits from more than one class. [NOT SUPPORTED], and this can be possible using interfaces

------------------------
3) Encapsulation (here we restrict the direct access to our main class, we use private methods for that)
- Encapsulation is the process of bundling variables and methods (functions) that operate on the data within a "single unit", known as a class.
   It helps protect an object’s internal state by restricting direct access to its attributes and providing controlled access through public methods.
- Encapsulation is the concept of hiding the internal details of a class and only allowing access through public methods. (DATA HIDING)
- we use public getter and setter methods to access and update the variables.

------------------------
4) POLYMORPHISM
- Polymorphism means one thing can take many forms.
- In Java, it allows a single method or object to behave differently in different situations.
Eg: Method overloading(Compile-time Polymorphism), method overriding(Runtime Polymorphism)

-----------------------------------------------------------
-----------------------------------------------------------
OPTIONAL OOPS (Association, Aggregation, Composition)


a) Association : (here both classes are independent) Association is a relationship between two separate classes where one class uses or interacts with another class,
                 but both can exist independently. It represents a “uses-a” relationship.
Eg:
class Teacher {
    String name;
    Teacher(String name) { this.name = name; }
}

class Student {
    String name;
    Student(String name) { this.name = name; }

    void assignTeacher(Teacher t) {  //here we are using the Association
        System.out.println(this.name + " is assigned to teacher " + t.name);
    }
}

public class Main {
    public static void main(String[] args) {
        Teacher t1 = new Teacher("Mr. Sharma");
        Student s1 = new Student("Bhargav");

        s1.assignTeacher(t1); // Bhargav is assigned to teacher Mr. Sharma
    }
}


----------------------------------
2) Aggregation (here both classes are independent)
- Aggregation is a special form of association that represents a “Has-A” relationship between two classes.
- Aggregation is a relationship where one class owns or uses another class, but the contained object can exist independently of the container object.
  The part can exist without the whole.
- Has-A relationship but can live without it.

EG:
class Department {
    String name;
    Department(String name) { this.name = name; }
}

class College {
    String name;
    Department dept;    //AGGREGATION  <-------------------------

    College(String name, Department dept) {
        this.name = name;
        this.dept = dept;
    }

    void show() {
        System.out.println(name + " has department " + dept.name);
    }
}

public class Main {
    public static void main(String[] args) {
        Department d = new Department("Computer Science");
        College c = new College("SRKR College", d);
        c.show(); // SRKR College has department Computer Science
    }
}

----------------------------------
3) Composition (Both classes are dependable)
- Composition is a stronger form of aggregation. In composition, the contained object cannot exist without the container —
  both have a dependent life cycle.
- Has-A relationship and cannot live without it.

Eg:
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine;

    Car() {
        engine = new Engine(); // created inside the class → tightly bound    <----------------------------
    }

    void startCar() {
        engine.start();
        System.out.println("Car started");
    }
}


--------------------------------------------------------------------------
--------------------------------------------------------------------------
COLLECTIONS
- The Java collection framework is a set of classes and interfaces that provide a standard way of representing, manipulating and storing collections of objects .

* Important Points:
- List: an ordered collection of elements that allows duplicates and nulls.
- Map: a collection of key-value pairs, where each key is unique.
- HashMap: Here it dont follow any order or insertion order.
- LinkedHashMap: Combination of HashMap and linkedList, Maintains insertion order (the order you added keys)
- Queue: a queue is a data structure that is used to store elements in a First-In-First-Out (FIFO) manner.
- Deque: can be used both as FIFO and LIFO.
- Set: a unordered collection of elements that do not allow duplicates.
- Sorted set: Maintains the elements in a ascending order.
- Hash set : it used hashing mechanism(hash code) to store the unique elements.

1) List:
- It is an ordered collection of elements, where each element has a distinct position in the list.
- allows duplicates and nulls.

a) ArrayList
- its a growable or resizable array.
- It maintains order
- Allows duplicates

b) LinkedList
- It can impliment either List or Queue.
- It is good for inserting and deleting at the beginning and middle
- it is like a chain of nodes where each node can point to the previous and next node.

---------------------------
*) Iterator
- we use this when we want to go through every element in the list and access the elements accordingly.
- Its a one directional means can go from start to end (.hasNext()).
- Its an interface

*) ListIterator
- it is only applicable for the classes which are only implimenting list interface.
- its a bi-directional. (.hasNext(), .hasPrevious()) and it has read and write access.

---------------------------
*) Generics : To restrict the datatype of the elements you want to store in the list.