***Complete Junit Related Notes***

Important Points:
> Whenever we are testing something like testing some method in one class, Then we have to create an instance of that class. For static methods its not required.
> JUnit creates new test object per test method


Mockito Imp Points
> When objects are created using new inside the class, Mockito cannot replace them or mock them, so the mock can't be used.
  - in our main class "private PaymentGateway paymentGateway = new PaymentGateway();" -- this is wrong.
  - In your main class create it like this "PaymentGateway paymentGateway;" -- then @InjectMocks can inject the mocks correctly.

======================================================================================================
Junit Notes:

a) Test Lifecycle: four types, Used to manage shared resources, initialization, and cleanup.
1. Before all tests
2. Before each test
3. After each test
4. After all tests

------------------------------------------------------------------
b) Core Annotations

1. @Test
> To tell the junit that this is a test method, so Execute it. if we put this annotation then the Junit know that this method needs to run.
> It is used to mark a method as a test case so the JUnit Platform can discover it and execute it.
> The central annotation for writing tests.

2. @BeforeEach
> Mainly used for init logic.
> Runs before every test method.
> Used for per-test initialization.
> for creating fresh objects.

3. @AfterEach
> Runs after every test method.
> Used for cleanup.
> Close resources, reset external state.

4. @BeforeAll
> Runs once before all tests in the class.
> Must be static by default.
> Typical use: Expensive setup (database, server, shared resources).

5. @AfterAll
> Runs once after all tests in the class.
> Must be static by default.
> Typical use: Global cleanup.

6. @Disabled
> Disables a test or test class.

7. @ParameterizedTest
> Same test with multiple inputs

------------------------------------------------------------------
c) Assertions (Verification API) (Assertions validate expected outcomes.)

Main Assertions Methods

1. assertEquals : Verifies expected value equals actual value.
2. assertNotEquals : Verifies values are different.
3. assertTrue: Verifies a condition is true.
4. assertFalse: Verifies a condition is false.
5. assertNull: Verifies an object is null.
6. assertNotNull: Verifies an object is not null.
7. assertSame: Verifies two references point to the same object.
8. assertNotSame: Verifies two references do not point to the same object.
9. assertArrayEquals: Verifies array contents are equal.

> Exception Assertions
1. assertThrows: Verifies that a specific exception is thrown.
2. assertDoesNotThrow: Verifies that no exception is thrown

> Grouped Assertions
1. assertAll: Executes multiple assertions and reports all failures together.

======================================================================================================

* Basic Junit reference code is in these files - YT Tutorial example
> Java Class : com/aem/geeks/core/javarelatedcodes/junitrelated/AddClass.java
> Test Class : com/aem/geeks/core/javarelatedcodes/junitrelated/AddClassTest.java

* All Junit code annotation examples are in these
> com/aem/geeks/core/javarelatedcodes/junitrelated/JunitExampleClass.java
> com/aem/geeks/core/javarelatedcodes/junitrelated/JunitExampleClassTest.java

======================================================================================================
MOCKITO

1. @Mock
> Creates a mock object â€” a fake version of a real class where you control the behavior of its methods.
> Use it when your class under test depends on other classes (services, repositories, APIs, etc.) and you
  want to avoid calling the real implementation. This helps isolate the unit you are testing.


2. @InjectMocks
> Creates an instance of the class being tested and automatically injects the mocks (created using @Mock) into it.


3. @Spy
> Creates a partial mock


4. @Captor
> Captures the values passed into method calls during the test so that you can later inspect them.
> Use it when you need to verify what arguments were passed to a dependency method.
> Very useful when the method parameters are complex objects and you need to confirm their internal values.


5. @ExtendWith(MockitoExtension.class)
> Enables Mockito annotations (@Mock, @InjectMocks, etc.) in the test class.
> Required in JUnit 5 tests so Mockito can initialize all annotated objects automatically. Without this, annotations may not work.











































