=============================================================================================
QUICK IMPORTANT NOTES

=============================================================================================
IMPORTANT PATHS
-> For Configurations(crx) : apps/system/config, (preferred path is /apps/my-prjt/osgiconfig/config)
-> For Checking the sling Adapters : /system/console/adapters
-> AEM replication agents : /etc/replication/agents.author.html
-> Check the available run modes : /system/console/status-slingsettings
-> To Check the status of the scheduler : /system/console/status-slingscheduler
-> Workflow model usually stored in two places in our jcr
       1. Design Model - Stored Under (crx) : /conf/global/settings/workflow/models
       2. Runtime Model - Stored Under (crx) : /var/workflow/models
       * The WF STEP dialog values are stored inside : /conf/global/settings/workflow/models/bhargav-personal-workflow/jcr:content/flow/geeksworkflowstep/metaData
-> We can find all the available users( and also deactivate the user here) : /security/users.html
-> To create new service user : /crx/explorer/index.jsp

-> In Manual System User creation,
    - to create new user : crx/explorer/index.jsp
    - To give the required permissions(ACL's) : /Useradmin
    - Note: Service users are under this path (crx) : /home/users/system


=============================================================================================
1) Logger Levels
        Trace
        |
        Debug
        |
        Info
        |
        Warn
        |
        Error

* For Eg: If you give log level as "Info" for the log file, so in that file "Trace & Debug" logs wont print, "Info, Warn, Error" logs will print in that file.

=============================================================================================
2) Global Objects available in HTL (most common ones)

-> Enumerable Objects : These objects provides a "VALUEMAP" which contains the information, we can access that info.
- properties : Provides the component properties, like whatever we save through dialog, we can access those props without using sling model.
- pageProperties : This will provide you the properties or info of page where our component used, In simple words getting page informatuion
- inheritedPageProperties : It provide the inherited properties of page, we can access the properties of the parent page

-> Demo code available here: apps/aemgeeks/components/content/author-books/author-books.html

---------------------------------------
-> Java-Backed-Object
- Component : Provides the information of that component.
- componentContext : It is open for each conmponent, Independent of wcmmode.
- resource : object of current resource(when we drag and drop a comp on page, then the created node of that comp in that page is called as current Resource).
- resourcePage : On the page where we drag and drop the component, It provides the information of that page means the current page
- currentDesign : there is a design node available to store the template level properties, that info we can get through this. if nothing is set
                  then it gives the default libs design node path
- currentNode : when we drag and drop a component on a page, then that comp node is treated as a current node.
- currentPage
- resourceDesign : it is the same as the current design
- wcmmode : It provide you the information, that in which mode you are, returns "boolean", for EDIT: isEdit method, for Preview: isPreview method.

-> Demo code available here: apps/aemgeeks/components/content/author-books/author-books.html

=============================================================================================
3) MANDITORY METHODS

a) Sling Models : No manditory methods
b) Services : No manditory methods
c) Servlets :
        - ResourceType : No manditory Methods, but based on the requirement we will use doGet, doPost, doPut, doDelete
        - PathType     : No manditory Methods, but based on the requirement we will use doGet, doPost, doPut, doDelete

d) Configurations:
        - Normal   : No manditory method, but have to define "activate" method to get the config values
        - Factory Configuration : a) Activate - not a manditiory, but have to define for getting the config values.
                                  b) BIND Method
                                  c) UnBind Method

e) Schedulers : we have two types of schedulers 1) Runnable, 2)Job Scheduler
                1)Runnable : RUN() method is the manditory one. "activate method", Not a manditory method, but to get the config values we define it
                2)Job  : execute(JobContext jobContext) is the manditory method, "activate method", Not a manditory method,
                         but to get the config values we define it.

f) Workflow :
            1) Custom WF Process : execute(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap processArguments)

=============================================================================================
4) PAGE MANAGER
pageManeger: using this we can get the page we want.

eg:
@ScriptVariable
PageManager pageManager;
Page page=pageManager.getPage("/content/aemgeeks/us/en");

=============================================================================================
5) @Component
--> Servlets : @Component(service = Servlet.class)
--> OSGI Configuration Service : @Component(service = OSGiConfigService.class,immediate = true)   [OSGiConfigService.class  -> this is just my interface service I created]
--> Schedulers :
                - Runnable : @Component(immediate = true, service = Runnable.class)
                - Job :  @Component(immediate = true, service = Job.class)

--> Service : @Component(Service = bhargavService.class)  - bhargavService is my interface and I am linking it to my implimentation class using @Component
--> Workflow : @Component(service=workflowProcess.class)
=============================================================================================
6) ANNOTATIONS:
@Activate : when we want something to load or activate at the time of this service initializations, there we use this
@ObjectClassDefinition(name, definition) : used for defining osgi configuration.
@Modified : It is a lifecycle callback method annotation used in OSGi components. It marks a method that should be called
            whenever the OSGi configuration for that component is changed at runtime, without restarting the bundle.
- In simple words, When you change configuration values, AEM will automatically re-invoke the method annotated with @Modified, So your service picks up
  the new configuration immediately — without redeploying or restarting AEM.

=============================================================================================
7) SERVLETS - GET and POST requests explanation

--> GET FLOW
a) Browser issues GET /path?query=abc HTTP/1.1 (headers, cookies).
b) Server/router receives request, Sling/Servlet container resolves resource/servlet.
c) Container calls doGet(req, res)
d) doGet reads req.getParameter(...), session, headers, etc., prepares content and sets response headers (Content-Type, caching),
writes body via res.getWriter() or stream.
e) Server sends HTTP status (200 OK) + body back.
f) Browser renders or caches per response headers.

--> POST FLOW
a) Browser issues POST /path HTTP/1.1 with body (form-encoded, JSON, multipart) + headers.
b) Transports to the server.
c) Container resolves servlet and calls doPost(req, res).
d) doPost reads req.getParameter() (for form), validates input, performs DB/JCR writes.
f) doPost typically returns: HttpStatus codes and then Client receives response and acts accordingly.

=============================================================================================
9) req.setAttribute() AND req.getAttribute()  Explanation with Example

Q) What is an “attribute” in a request?
Answer: You can store temporary data in the HttpServletRequest object using setAttribute() and later read it back using getAttribute().
--> Think of a HttpServletRequest (or SlingHttpServletRequest) object as a container or bag that travels from the
    browser → AEM → servlet → JSP → other servlets.
--> That bag can carry
a) Parameters (from the user input, like req.getParameter("name"))
b) Headers (like cookies, content-type)
c) And also... attributes that developers can manually add.

--> So attributes are temporary data stored inside the request object — for this single request only.
--> req.setAttribute("key", value);  => Adds a data item to the request.
--> req.getAttribute("key");  => Retrieves that data item later.

--> Example With code snippets: Imagine you’re processing a registration form.
Step 1: You receive a POST request.
String name = req.getParameter("name");
String email = req.getParameter("email");

- Now, before forwarding this to a JSP page or another servlet, you want to store these values inside the request temporarily

Step 2: Set attributes
req.setAttribute("userName", name);
req.setAttribute("userEmail", email);
- Now your req object carries these attributes.

Step 3: Forward the request
RequestDispatcher dispatcher = req.getRequestDispatcher("/thankyou.jsp");
dispatcher.forward(req, res);

- Then inside your JSP (HTL or JSP):
<p>Welcome ${requestScope.userName}! Your email is ${requestScope.userEmail}</p>  --> Output : Welcome Bhargav! Your email is bhargav@example.com

Final understanding: (temporary notepad that travels along with one request) Here with in the request, until the req is there at that time we are setting
these attr(variables) userName, userEmail with our data.

Note: We can forward this attributs from one servlet to another, like we can set these attributs in one servlet and then get these in another servlet
// Forward the request to another servlet
RequestDispatcher dispatcher = req.getRequestDispatcher("/second");
dispatcher.forward(req, res);

=============================================================================================
10) MULTIFIELD - COMPOSITE PROPERTY (composite="{Boolean}true")
- we will add this property while defining a multifield in content dialog, by default it is false
- FALSE : In this case, if we give two set of values to the multifield in the comp dialog, then it store those two sets values in a "STRING ARRAY" inside component node.
- TRUE : In this case if we provide two sets of values to the multifield in the comp dialog, it will create a node under our component node(with name we have give
          for multifield in xml) and then under that node it will create a two item nodes for those two sets of values.
- we use false when we have a single field in the multifield, and true when we have a multiple fields in the multifield.
-> We can render the multifield values using two ways one is using MAP and the other way is using JAVA BEAN

=============================================================================================
11) Sling Model Content Exporter (Content as a Service)
- AEM comes up with OOTB content exporter functionality, means AEM can export content to third party systems in form of JSON or XML.

=============================================================================================
12) Utility Functions available in Sightly: in, format, join

=============================================================================================
13) RUN MODES
- Run Modes in AEM are a way to customize the behavior and configuration of an AEM instance for different environments (like author, publish, dev,
  stage, prod, etc.) using the same codebase.
        PURPOSE of runmodes:
        *Separate configurations for Author and Publish.
        *Maintain different settings for Dev / QA / Prod.
        *Control which components, workflows, or OSGi configurations are active.
- When we want to identify our AEM instance uniquely, either in code(slingSettingService.getRunModes()) or in osgi configs, we set run modes. run modes are two types.
a) Installation Run modes (permanant run modes) : these we will set while installing aem instance. and we cannot change these runmodes,  these are four
                                                  types
                                                1. Author
                                                2. Publisher
                                                3. SampleContent  - Means aem will give you the basic sample pages like WE-RETAIL
                                                4. NoSampleContent - no sample or demo sites (means no we retail or wknd)
   - Author & Publisher, sampleContent & NoSampleContent are mutually exclusive means we cannot use them together.
   - By default if we do not set anything, aem will automaytically create Author with SampleContent.

b) Customized Run Modes : Runmodes we create like Prod, Stg, Qa, Ciqa

=> Creation of Run Modes, we have 5 ways
1) Sling.Properties : we wont prefer this because we won't have permissions. and it is OOTB file so we should not change.
2) system properties (-D) -Dsling.run.modes=publish,prod,us : this we can create while starting our aem instance
3) Filename Detection - aem-publsh-p4503 (most commonly used): we remane a file, and then while installing the aem will understand what run mode it is.
4) -r option -  java-jar file-r publish,prod,us: here while starting the aem we update the start script so then it will create a run mode,
    (2nd and 4th options are almost same)
Note : we can check the available run modes at /system/console/status-slingsettings

Q) How do you configure OSGi differently for Author and Publish?
ans. “By placing configuration files inside run mode–specific folders like /apps/project/config.author and /apps/project/config.publish.
AEM automatically picks the correct configuration based on its active run mode.”

=============================================================================================
14) SCHEDULERS
a) Runnable scheduler
- implements runnable interface
- With this we can execute only one job.

b) Job Scheduler
- Implements JOB interface
---> USE OF THIS JOB SCHEDULER
- Lets say we have a component and a scheduler, the component displays the data and the scheduler fetches the data from some
service and update the data in the component. lets say we have three countries INDIA(12:00AM), GERMANY(12:00 AM), USA(12:00 AM),
and from these three countries we are getting the data. our scheduler executes at midnight 12:00 AM and fetches the data of
covid 19 patients from some service. Our servers are in india so for india it is fine but for the usa and germany 12AM IST
is not a 12AM for them (INDIA 12AM -- USA 1:30PM -- GERMANY 4:30PM), so based on this to meet the requirement our scheduler should
execute at three different times, and for that writing three Runnable Schedulers(different corns) is not a feasable way.
In this scenario JOB SCHEDULERS enter, we can write three jobs for these three countries in one scheduler.

=============================================================================================
15) WORKFLOWS in AEM
- Workflow model usually stored in two places in our jcr
    1. Design Model - Stored Under : /conf/global/settings/workflow/models
    2. Runtime Model - Stored Under : /var/workflow/models   -> when the workflow executes then this run time model will be used.

- Two make the changes go from Design to Runtime we have to click the "SYNC".
* Basically to trigger a workflow we need Two things 1.Workflow Model, 2.Payload(means the content path on which we want to run our WF, like page, asset etc)
    - Incase of triggering WF using code, then in that case to get this Payload we will use "WorkflowSession"

----------------------------------------
* Custom WF Process
- When no existing process is available based on our requirement then we can write our own custon WF process. This "CUSTOM WF PROCESS" is available in
  the dropdown Of "PROCESS STEP"(this process step is provoded by aem only in this we use it). this will won't have its own dialog.
- To write this we have to impliment an interface called "WorkflowProcess"

NOTE: execute(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap processArguments) uses of these parameters in this manditory method
        * WorkflowSession: Using this we can get the backend objects, using this only we get the ResourceResolver, Session using this WorkflowSession.
        * MetaDataMap : If we pass any data to the dialog, that data we can get using this.(in case of custom WF process we get the data we have
                        given in "ARGUMENTS" process step dialog box)(in case of normal process step we can get the data we have given in dialog box of that step).
        * WorkItem : we might have the steps before and after our process step, and there will be an information and payload flowing from starting of our WF model till end
                    .that payload and the other information should be available in our Custom WF Process and that all information is available in "WorkItem".
                    apart from the available information we can also pass the other information as we want.

----------------------------------------
Note: Custom WF Process and Custom WF step is not same, the difference is Custom WF Process is a backend module and it won't have it own step
      we use the already available "PROCESS STEP" to use this Custom WF Process, But in "Custom WF step" we have a Custom WF Process and also
      its own step in the available steps and also have its own dialog box.

----------------------------------------
* Custom Workflow STEP
- Combination of Custom WF Process + Component(this comp wont have any rendering script and backend module) is called a Custom Workflow STEP.
- The comp will have a cq:dialog, cq:editConfig
- this step will be available in the available steps in the WF Model console.

* COMPONENT:
- (IMP) The comp will have a cq:dialg, cq:editConfig. and  cq:editConfig has a child node called cq:formParameters and in that there is a property
        called "PROCESS", for that property we give the value of our custom wf process, so in this way using that property we link this comp to
        our custom wf process.
- And in our component "sling:resourceSuperType="cq/workflow/components/model/process", means our comp is just inheriting the existing "PROCESS STEP" by pointing to it.
- In cq:formParameters node for "PROCESS" property we give the custom wf process as a value.
    eg: PROCESS="com.aem.geeks.core.workflows.GeeksWorkflowStep"

- (IMP) In the component the dialog fields name property value should be given with metadata.
            - Eg: for brand field name:./metaData/BRAND
            - So this is because when the model is saved this will save the data in a node called metadata.

- All the values given in the WF STEP dialog box are stored inside this metadata node:
    /conf/global/settings/workflow/models/bhargav-personal-workflow/jcr:content/flow/geeksworkflowstep/metaData

=============================================================================================
16) Asset API --> Asset asset = resource.adaptTo(Asset.class);

- By doing this "Asset asset = resource.adaptTo(Asset.class);", we are converting the generic resource into an AEM DAM Asset API object
  that provides higher-level methods.

- for example:
* asset.getMetadataValue("dc:title")
* asset.getOriginal()
* asset.getRenditions()
* asset.addRendition(...)
* asset.getMimeType()

=============================================================================================
17) adaptTo()

* It is simply like a variable converting thing, eg: Node node = resource.adaptTo(Node.class);  -> here we are converting our resource to node.

* Different Types:
1. Resource → adaptTo(ValueMap.class)
 - Use when: you only need properties of the resource. use when we just want the properties stored on this resource.
 - Eg: Read title, description, custom component fields, Fetch simple configuration values, Access metadata properties quickly.
 - Code eg : ValueMap props = resource.adaptTo(ValueMap.class);
             String title = props.get("jcr:title", String.class);

2. Resource → adaptTo(Node.class)
 - Use when: you need low-level JCR operations.
 - eg: Add/remove nodes manually, Set properties using JCR APIs.
 - Code eg: Node node = resource.adaptTo(Node.class);
            node.setProperty("myProp", "value");

3. Resource → adaptTo(Page.class)
 - Use when: the resource represents a page and you need page-specific methods.
 - eg: Get page title, template, parent page, Navigate site structure, Check if page is valid or published.
 - Code eg: Page page = resource.adaptTo(Page.class);
            String title = page.getTitle();

4. Resource → adaptTo(Asset.class)
 - Use when: the resource represents a DAM asset and you need asset functionality.
 - eg: Read asset metadata, Get renditions (original, thumbnails), Access binary streams, Add new renditions.
 - Code eg: Asset asset = resource.adaptTo(Asset.class);
            String mimeType = asset.getMimeType();

=============================================================================================
18) USING ResourceResolver and Session and modifying the nodes (Basic Codes) (IN-DEPTH ABOUT THIS IN NEXT BLOCK)

- In SERVLET(where the methods give us in-built Request) (So we get a resourceResolver using that request)
Steps:
1 - Getting the "Request"
    ->  doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)

2 - Getting ResourceResolver from the request
    -> ResourceResolver resourceResolver = request.getResourceResolver();

3 - Converting the ResourceResolver to session(something like datatype conversion) (we can only get the session when we have a resourceResolver)
    -> Session session = resourceResolver.adaptTo(Session.class);

4 - Basic page path
    -> String parentPath = "/content/aemgeeks/us/en";

5 - getting hold of the page resource using ResourceResolver
    ->Resource parentResource = resourceResolver.getResource(parentPath);

6 - Converting or Resource to Node, so that we can do the modifications
    -> Node parentNode = parentResource.adaptTo(Node.class);

7 - Doing some node modifications
    -> Node newNode = parentNode.addNode("sampleNode", "nt:unstructured");
                       newNode.setProperty("title", "My Sample Node");
                       newNode.setProperty("createdBy", "Bhargav");
                       newNode.setProperty("year", 2025);

8 - Saving the session
    -> session.save();


** In sling model we get the "ResourceResolver" using
   @SlingObject
    private ResourceResolver resourceResolver;

=============================================================================================
*** VERY IMPORTANT NOTES **** GETTING ResourceResolver, Resource, Request, Session, Node *** (In-Depth)

IMP POINTS:
> Session always comes from ResourceResolver, and ResourceResolver comes from 1) request, 2) resource, 3) resolverFactory depending on context.
> In Servlets or Sling Models, AEM automatically provides a ResourceResolver because they are request-based (A Sling request gives you a resolver).
> But in Services, Schedulers, or Workflows, there is no request and no automatic context — so AEM doesn’t know who is trying to access the repository.
  in that cases we need "ResourceResolverFactory" to get the ResourceResolver.
> In WF Process --> Using "WorkflowSession" we get the "ResourceResolver", "Session".
> We have to close the "ResourceResolver" after using. ->  resourceResolver.close();,
   - And importantly we have to Close the resolver only when we created it(means resolverFactory.getServiceResourceResolver(...)).
   - Short memory trick ---> Created it → close it :: Framework provided it → do not close it.

---------------------------------------
* WAYS OF GETTING HOLD OF NODE and DOING READ AND WRITE AND THEN SAVING IT

1) Using ResourceResolver (Common way – read + write)
        - Getting the hold of resource using ResourceResolver
            Resource resource = resourceResolver.getResource("/content/mySite/page/jcr:content");

        - Reading the node properties of that resource
            Node node = resource.adaptTo(Node.class);    //here we are converting our resource to node.
            String title = node.getProperty("jcr:title").getString();

        - writing the node properties of that resource and saving the session.
            Node node = resource.adaptTo(Node.class);
            node.setProperty("jcr:description", "Updated via ResourceResolver");
            node.getSession().save();

---------------------------------------
2) Using JCR Session
        - Getting the session using ResourceResolver
            ResourceResolver resourceResolver = request.getResourceResolver();
            Session session = resourceResolver.adaptTo(Session.class);

        - Reading
            Node node = session.getNode("/content/mySite/page/jcr:content");
            String title = node.getProperty("jcr:title").getString();

        - Writing and saving
            node.setProperty("jcr:description", "Updated via Session");
            session.save();

---------------------------------------
3) In SLING MODEL : in sling model we can directly get the resource, without using ResourceResolver.

    - getting the current resource
            @Inject   (only @inject may give null sometimes, so either use both @inject, @self or use @SlingObject)
            private Resource resource;

    - Getting the Node and reading
            Node node = resource.adaptTo(Node.class);
            String propValue = node.getProperty("jcr:title").getString();

    - Writing and saving
            node.setProperty("jcr:description", desc);
            node.getSession().save();

* Here using @SlingObject also we can get the ResourceResolver
            @SlingObject
             private ResourceResolver resourceResolver;

---------------------------------------
4) In Servlet :
* The methods like doGet and doPost will in-built give the "SlingHttpServletRequest request" from the request we can get the "ResourceResolver"
    - Getting the ResourceResolver
            protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response){
                    ResourceResolver resourceResolver = request.getResourceResolver();

    - Using this ResourceResolver we get the hold of resource
            Resource resource = resourceResolver.getResource("/content/mySite/page/jcr:content");

    - Coverting the available resource to node
            Node node = resource.adaptTo(Node.class);

    - Reading, writing and saving
            String title = node.getProperty("jcr:title").getString();

            node.setProperty("jcr:description", "Updated via Servlet");
            node.getSession().save();

---------------------------------------
5) In Service, Scheduler :
* Here in service we use "ResourceResolverFactory" to get the ResourceResolver.
* Demo for this refer
    1) com/aem/geeks/core/utils/ResolverUtil.java
    2) com/aem/geeks/core/services/impl/ComponentsInfoServiceImpl.java

    - Getting ResourceResolverFactory
            @Reference
            private ResourceResolverFactory resolverFactory;

    - Getting ResourceResolver using ResourceResolverFactory
            final Map<String, Object> paramMap = new HashMap<String, Object>();
            paramMap.put( ResourceResolverFactory.SUBSERVICE, GEEKS_SERVICE_USER );
            ResourceResolver resolver = resourceResolverFactory.getServiceResourceResolver(paramMap);  //here we got the ResourceResolver

    - Getting the resource using ResourceResolver
            Resource resource = resolver.getResource("/content/mySite/page/jcr:content");

    - Converting this resource to node
            Node node = resource.adaptTo(Node.class);

    - Reading, Writing and saving
            String title = node.getProperty("jcr:title").getString();
            node.setProperty("jcr:description", "Updated via OSGi Service");
            node.getSession().save();

---------------------------------------
6) In Workflow
* Using "WorkflowSession" we get the "ResourceResolver", "Session".
* Reference is in ->  com/aem/geeks/core/workflows/GeeksWorkflowProcess.java

    - Getting the JCR:Session and Payload path
            public void execute(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap processArguments) {
                    Session session = workflowSession.adaptTo(Session.class);   //Got the session
                    WorkflowData workflowData = workItem.getWorkflowData();
                    String path = workflowData.getPayload().toString() + "/jcr:content";   // got the payload resource path as a string

    - Getting Node using session
            Node node = (Node) session.getItem(path);

    - Writing and saving
            node.setProperty("jcr:description", "I am in Workflow");
            session.save();

---------------------------------------
7) Special mention - Using Page API
    - Getting hold of resource
          PageManager pageManager=resourceResolver.adaptTo(PageManager.class);
          Page page = pageManager.getPage("/content/mySite/page");
          Resource contentRes = page.getContentResource();  //here we directly got the jcr:content

    - Reading using ValueMap
          ValueMap valueMap = contentRes.getValueMap();  // here it will allow you to read all the properties in that resource node
          String title = valueMap.get("jcr:title", String.class);

    - Reading, Writing and saving using node
          Node node = contentRes.adaptTo(Node.class);
          String title = node.getProperty("jcr:title").getString();
          node.setProperty("jcr:description", "Updated via Page API");
          node.getSession().save();


---------------------------------------
8) Classes or interfaces that helps in Accessing HTTP & External API  (for REST / external systems)
- HttpClient (HttpGet, HttpPost) : Used to make external REST API calls.
- HttpURLConnection (Java standard) : Simplified way to call REST APIs using core Java.
- CloseableHttpClient : Common AEM approach for secure API calls.
- JSONObject / Gson : To parse and handle JSON responses from APIs.

---------------------------------------
* MAPS - COMPLETE IMPORTANT map showing how Resource, ResourceResolver, Node, Session, and related APIs connect across AEM.

[ ResourceResolverFactory ]
          │
          ▼
 [ ResourceResolver ] ────► provides access to Repository (read/write)
          │
          ├──► getResource("/path/to/node")
          │        │
          │        ▼
          │    [ Resource ]  ← Sling representation of a JCR node
          │        │
          │        ├──► adaptTo(ValueMap) → for reading properties
          │        └──► adaptTo(Node) → for direct JCR access
          │                 │
          │                 ├──► getProperty("jcr:title") → read
          │                 ├──► setProperty("prop", "value") → write
          │                 └──► getSession() → obtain Session
          │
          └──► adaptTo(Session)
                     │
                     ▼
              [ JCR Session ]
                     │
                     ├──► getNode("/path/to/node")
                     ├──► save()   ← commits changes
                     └──► logout() ← closes session

---------------------------------------
* Common Flows

-> READING
        ResourceResolver → getResource(path)
               ↓
        Resource → adaptTo(Node)
               ↓
        Node → getProperty("propName")

-> WRITING
        ResourceResolver → getResource(path)
               ↓
        Resource → adaptTo(Node)
               ↓
        Node → setProperty("prop", "value")
               ↓
        Node.getSession().save()


-> Just One Line Summary
        ResourceResolverFactory
           ↓
        ResourceResolver
           ↓ getResource()
        Resource
           ↓ adaptTo(Node)
        Node
           ↓ getSession()
        Session.save()

=============================================================================================
MSM:
* MSM helps you manage multiple websites that share common content or structure. It lets you reuse pages, but still localize or update them differently
  in other sites.

* Structure Map:
/content
 └── we-retail
      ├── blueprint (source)
      │    ├── en
      │    │    ├── us
      │    │    └── uk
      │    └── fr
      │         ├── fr
      │         └── ca
      │
      ├── language-copies
      │    ├── en
      │    └── fr
      │
      └── live-copies (targets)
           ├── us-site  ← (Live Copy from blueprint/en/us)
           ├── uk-site  ← (Live Copy from blueprint/en/uk)
           └── fr-site  ← (Live Copy from blueprint/fr/fr)


* Blueprint(Master site): The master/source site from which other sites (Live Copies) are created.
  Eg: /content/we-retail/blueprint/en

* Language Copy(Translated version): - A copy of a site in another language.
                 - Once you create a Language Copy(fr), AEM just duplicates the content into another language folder — and then stops tracking it.
                 - After that, the two are completely independent(en and fr).
                 - There’s no automatic sync or inheritance like Live Copies have.
  Eg: From /content/we-retail/en → you create /content/we-retail/fr.

* Live Copy(Automatically synced child of Blueprint): A site that inherits content from a Blueprint (or another source) through MSM.

=============================================================================================

