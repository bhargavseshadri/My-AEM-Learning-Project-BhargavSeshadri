=============================================================================================
QUICK IMPORTANT NOTES

=============================================================================================
IMPORTANT PATHS
-> For Configurations(crx) : apps/system/config, (preferred path is /apps/my-prjt/osgiconfig/config)
-> For Checking the sling Adapters : /system/console/adapters
-> AEM replication agents : /etc/replication/agents.author.html
-> Check the available run modes : /system/console/status-slingsettings
-> To Check the status of the scheduler : /system/console/status-slingscheduler

=============================================================================================
2) Global Objects available in HTL (most common ones)

-> Enumerable Objects : These objects provides a "VALUEMAP" which contains the information, we can access that info.
- properties : Provides the component properties, like whatever we save through dialog, we can access those props without using sling model.
- pageProperties : This will provide you the properties or info of page where our component used, In simple words getting page informatuion
- inheritedPageProperties : It provide the inherited properties of page, we can access the properties of the parent page

-> Demo code available here: apps/aemgeeks/components/content/author-books/author-books.html

---------------------------------------
-> Java-Backed-Object
- Component : Provides the information of that component.
- componentContext : It is open for each conmponent, Independent of wcmmode.
- resource : object of current resource(when we drag and drop a comp on page, then the created node of that comp in that page is called as current Resource).
- resourcePage : On the page where we drag and drop the component, It provides the information of that page means the current page
- currentDesign : there is a design node available to store the template level properties, that info we can get through this. if nothing is set then it gives the default libs design node path
- currentNode : when we drag and drop a component on a page, then that comp node is treated as a current node.
- currentPage
- resourceDesign : it is the same as the current design
- wcmmode : It provide you the information, that in which mode you are, returns "boolean", for EDIT: isEdit method, for Preview: isPreview method.

-> Demo code available here: apps/aemgeeks/components/content/author-books/author-books.html

=============================================================================================
3) MANDITORY METHODS

a) Sling Models : No manditory methods
b) Services : No manditory methods
c) Servlets :
        - ResourceType : No manditory Methods, but based on the requirement we will use doGet, doPost, doPut, doDelete
        - PathType     : No manditory Methods, but based on the requirement we will use doGet, doPost, doPut, doDelete
d) Configurations:
        - Normal   : No manditory method, but have to define "activate" method to get the config values
        - Factory Configuration : a) Activate - not a manditiory, but have to define for getting the config values.
                                  b) BIND Method
                                  c) UnBind Method
e) Schedulers : we have two types of schedulers 1) Runnable, 2)Job Schedulet
                1)Runnable : RUN() method is the manditory one. "activate method", Not a manditory method, but to get the config values we define it
                2)Job  : execute(JobContext jobContext) is the manditory method, "activate method", Not a manditory method, but to get the config values we define it

=============================================================================================
4) PAGE MANAGER
pageManeger: using this we can get the page we want.
eg:
@ScriptVariable
PageManager pageManager;
Page page=pageManager.getPage("/content/aemgeeks/us/en");

=============================================================================================
5) @Component
--> Servlets : @Component(service = Servlet.class)
--> OSGI Configuration : @Component(service = OSGiConfigService.class,immediate = true)
--> Schedulers :
                - Runnable : @Component(immediate = true, service = Runnable.class)
                - Job :  @Component(immediate = true, service = Job.class)

--> Service : @Component(Service = bhargavService.class)  - bhargavService is my interface and I am linking it to my implimentation class using @Component

=============================================================================================
6) ANNOTATIONS:
@Activate : when we want something to load or activate at the time of this service initializations, there we use this
@ObjectClassDefinition(name, definition) : used for defining osgi configuration.
@Activate : when we want something to be load or executed at the time of this service initiation
@Modified : It is a lifecycle callback method annotation used in OSGi components. It marks a method that should be called whenever the OSGi configuration for that component is changed at runtime, without restarting the bundle.
- In simple words, When you change configuration values, AEM will automatically re-invoke the method annotated with @Modified, So your service picks up
the new configuration immediately — without redeploying or restarting AEM.

=============================================================================================
7) SERVLETS - GET and POST requests explanation

--> GET FLOW
a) Browser issues GET /path?query=abc HTTP/1.1 (headers, cookies).
b) Server/router receives request, Sling/Servlet container resolves resource/servlet.
c) Container calls doGet(req, res)
d) doGet reads req.getParameter(...), session, headers, etc., prepares content and sets response headers (Content-Type, caching),
writes body via res.getWriter() or stream.
e) Server sends HTTP status (200 OK) + body back.
f) Browser renders or caches per response headers.

--> POST FLOW
a) Browser issues POST /path HTTP/1.1 with body (form-encoded, JSON, multipart) + headers.
b) Transports to the server.
c) Container resolves servlet and calls doPost(req, res).
d) doPost reads req.getParameter() (for form), validates input, performs DB/JCR writes.
f) doPost typically returns: HttpStatus codes and then Client receives response and acts accordingly.

=============================================================================================
9) req.setAttribute() AND req.getAttribute()  Explanation with Example

Q) What is an “attribute” in a request?
Answer: You can store temporary data in the HttpServletRequest object using setAttribute() and later read it back using getAttribute().
--> Think of a HttpServletRequest (or SlingHttpServletRequest) object as a container or bag that travels from the browser → AEM → servlet → JSP → other servlets.
--> That bag can carry
a) Parameters (from the user input, like req.getParameter("name"))
b) Headers (like cookies, content-type)
c) And also... attributes that developers can manually add.

--> So attributes are temporary data stored inside the request object — for this single request only.
--> req.setAttribute("key", value);  => Adds a data item to the request.
--> req.getAttribute("key");  => Retrieves that data item later.

--> Example With code snippets: Imagine you’re processing a registration form.
Step 1: You receive a POST request.
String name = req.getParameter("name");
String email = req.getParameter("email");

- Now, before forwarding this to a JSP page or another servlet, you want to store these values inside the request temporarily

Step 2: Set attributes
req.setAttribute("userName", name);
req.setAttribute("userEmail", email);
- Now your req object carries these attributes.

Step 3: Forward the request
RequestDispatcher dispatcher = req.getRequestDispatcher("/thankyou.jsp");
dispatcher.forward(req, res);

- Then inside your JSP (HTL or JSP):
<p>Welcome ${requestScope.userName}! Your email is ${requestScope.userEmail}</p>  --> Output : Welcome Bhargav! Your email is bhargav@example.com

Final understanding: (temporary notepad that travels along with one request) Here with in the request, until the req is there at that time we are setting
these attr(variables) userName, userEmail with our data.

Note: We can forward this attributs from one servlet to another, like we can set these attributs in one servlet and then get these in another servlet
// Forward the request to another servlet
RequestDispatcher dispatcher = req.getRequestDispatcher("/second");
dispatcher.forward(req, res);

=============================================================================================
10) MULTIFIELD - COMPOSITE PROPERTY (composite="{Boolean}true")
- we will add this property while defining a multifield in content dialog, by default it is false
- FALSE : In this case, if we give two set of values to the multified in the comp dialog, then it store those two sets values in a "STRING ARRAY" inside component node.
- TRUE : In this case if we provide a two sets of values to the multified in the comp dialog, it will create a node under our component node(with name we have give
          for multified in xml) and then under that node it will create a two item nodes for those two sets of values.
- we use false when we have a single field in the multifield, and true when we have a multiple fields in the multifield.
-> We can render the multifield values using two ways one is using MAP and the other way is using JAVA BEAN

=============================================================================================
11) Sling Model Content Exporter (Content as a Service)
- AEM comes up with OOTB content exporter funtionality, means AEM can export content to third party systems in form of JSON or XML.

=============================================================================================
12) Utility Functions available in Sightly: in, format, join

=============================================================================================
13) RUN MODES
- Run Modes in AEM are a way to customize the behavior and configuration of an AEM instance for different environments (like author, publish, dev, stage, prod, etc.)
  using the same codebase.
        PURPOSE of runmodes:
        *Separate configurations for Author and Publish.
        *Maintain different settings for Dev / QA / Prod.
        *Control which components, workflows, or OSGi configurations are active.
- When we want to identify our AEM instance uniquely, either in code or in osgi configs, we set run modes. run modes are two types.
a) Installation Run modes (permanant run modes) : these we will set while installing aem instance. and we cannot change these runmodes,  these are four types
                                                1. Author
                                                2. Publisher
                                                3. SampleContent  - Means aem will give you the basic sample pages like WE-RETAIL
                                                4. NoSampleContent - no sample or demo sites (means no we retail or wknd)
   - Author & Publisher, sampleContent & NoSampleContent are mutually exclusive means we cannot use them together.
   - By default if we do not set anything, aem will automay=tically create Author with SampleContent.

b) Customized Run Modes : Runmodes we create like Prod, Stg, Qa, Ciqa

=> Creation of Run Modes, we have 5 ways
1) Sling.Properties : we wont prefer this because we won't have permissions. and it is OOTB file so we should not change.
2) system properties (-D) -Dsling.run.modes=publish,prod,us : this we can create while starting our aem instance
3) Filename Detection - aem-publsh-p4503 (most commonly used): we remane a file, and then while installing the aem will understand what run mode it is.
4) -r option -  java-jar file-r publish,prod,us: here while starting the aem we update the start script so then it will create a run mode, (2nd and 4th options are almost same)
Note : we can check the available run modes at /system/console/status-slingsettings

Q) How do you configure OSGi differently for Author and Publish?
ans. “By placing configuration files inside run mode–specific folders like /apps/project/config.author and /apps/project/config.publish.
AEM automatically picks the correct configuration based on its active run mode.”

=============================================================================================
14) SCHEDULERS
a) Runnable scheduler
- impliments runnable interface
- With this we can execute only one job.

b) Job Scheduler
- Impliments JOB interface
---> USE OF THIS JOB SCHEDULER
- Lets say we have a component and a scheduler, the component displays the data and he scheduler fetches the data from some service and update the data in the component.
lets say we have three countries INDIA(12:00AM), GERMANY(12:00 AM), USA(12:00 AM), and from these three countries we are getting the data. our scheduler executes at midnight
12:00 AM and fetches the data of covid 19 patients from some service.
Our servers are in india so for india it is fine but for the usa and germany 12AM IST is not a 12AM for them (INDIA 12AM -- USA 1:30PM -- GERMANY 4:30PM),
so based on this to meet the requirement our scheduler should execute at three different times, and for that writing three Runnable Schedulers(different corns) is not a feasable way.
In this scenario JOB SCHEDULERS enter, we can write three jobs for these three countries in one scheduler.

=============================================================================================
15) USING ResourceResolver and Session and modifying the nodes (Basic Codes)

- In SERVLET(where the methods give us in-built Request) (So we get a resourceResolver using that request)
Steps:
1 - Getting the "Request"
    ->  doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)

2 - Getting ResourceResolver from the request
    -> ResourceResolver resourceResolver = request.getResourceResolver();

3 - Converting the ResourceResolver to session(something like datatype conversion) (we can only get the session when we have a resourceResolver)
    -> Session session = resourceResolver.adaptTo(Session.class);

4 - Basic page path
    -> String parentPath = "/content/aemgeeks/us/en";

5 - getting hold of the page resource using ResourceResolver
    ->Resource parentResource = resourceResolver.getResource(parentPath);

6 - Converting or Resource to Node, so that we can do the modifications
    -> Node parentNode = parentResource.adaptTo(Node.class);

7 - Doing some node modifications
    -> Node newNode = parentNode.addNode("sampleNode", "nt:unstructured");
                       newNode.setProperty("title", "My Sample Node");
                       newNode.setProperty("createdBy", "Bhargav");
                       newNode.setProperty("year", 2025);

8 - Saving the session
    -> session.save();


** In sling model we get the "ResourceResolver" using
   @SlingObject
    private ResourceResolver resourceResolver;